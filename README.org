-*- mode: org; mode: visual-line; -*-
#+STARTUP: indent

* =threejs-figwheel-main=

[[https://raw.githubusercontent.com/cassiel/threejs-figwheel-main/master/splash.jpg]]

This is an update of the repo [[https://github.com/cassiel/threejs-figwheel][threejs-figwheel]] which has been left behind in the churn of Clojure[Script] tooling development. We have switched to [[https://figwheel.org/][Figwheel Main]]. We are still building with [[https://leiningen.org/][Leiningen]].

The example code brings up a minimal [[http://threejs.org/][three.js]] 3D animated environment coded in ClojureScript, plus some bits of model building.

* Installation

We've followed the copious instructions [[https://figwheel.org/docs/installation.html][here]], opting for Leiningen rather than CLI Tools (mostly for familiarity). With Leiningen installed, it should be ready to run.

* Running

In a terminal:

#+BEGIN_SRC shell-script
  lein fig -- --build dev --repl
#+END_SRC

That brings up a terminal REPL and hot-reloading of files, and launches a browser window.

Or, for a full network REPL from emacs: =M-x cider-jack-in-cljs=, entering =figwheel-main= and =:dev= at the two prompts respectively.

If everything is working, there should be a simple tumbling cube-based model animated in a full-window canvas.

* Components

Whilst I generally prefer no-batteries-included examples to keep the content simple and focussed, for something stateful like three.js there are big benefits to using some off-the-shelf lifecycle code, so this project uses Stuart Sierra's [[https://github.com/stuartsierra/component][Component]], with a little bit of support from my own [[https://github.com/cassiel/lifecycle][Lifecycle]] library.

This leads to a slight oddity: launching the system from a ClojureScript file causes two startup attempts, which is benign but irritating. So the system is actually kicked off in a raw Javascript line embedded in =index.html= directly. I'm not convinced this is much better, but it does illustrate how to bring up and tear down the entire application from a browser console.

(Actually, another reason for doing this is that we wheel in three.js via [[http://cljsjs.github.io/][CLJSJS]], so that it gets compiled at the same point as our application code, but the externally loaded orbit controls (see below) depend on three.js whilst we need to call them from the application. If we don't launch the application immediately its code can refer to the orbit machinery before that's been defined.)

* Functional Style

There are some bits of functional style in =cube.cljs= (sequences generated by iterated function calls) to give an indication of how Clojure works well for generating iterative geometric structures in a mostly immutable manner (using three.js groups, for example).

* Orbit Controls

three.js's orbit controls have been implemented; note that these seem to disable pretty much all browser keyboard shortcuts (including many menu command keys) if focus is on the rendering canvas.

* To Do

- It's not clear that even tearing down the rendering context frees the memory used by meshes, geometries, materials etc.
- Fix the keyboard grab by the orbit controls.

* License

Copyright Â© 2020 Nick Rothwell, nick@cassiel.com.

Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version.
